# 当前运行的应用名称，因日志生成目录会使用该参数，所以必须有值，该值读取顺序为：读取启动参数中的MonitorAgent.service.name，不存在则读取skywalking.agent.service_name的配置值（兼容skywalking，无需重复配置），依然不存在则使用当前配置值，未配置则不增强应用（使用默认值可能导致日志被覆盖），不支持远程配置
service.name =
# 远程配置的url，支持多个地址配置，多个使用英文逗号分隔
config.remote_url =


############################ 插件启用/禁用配置
# 启用/禁用SPI，不配置默认为启用，禁用配置方式为：spi.类名=disable
#spi.JVMMetricsSchedule=disable
#spi.LocalConfigReader=disable
#spi.DisableSpiConfigReader=disable
#spi.CallEventAOP=disable
#spi.RTEventListener=disable
#spi.ConsumeAOP=disable
#spi.ConsumeBatchAOP=disable
#spi.KafkaConsumePropertiesAOP=disable
#spi.KafkaConvertAOP=disable
#spi.KafkaPublishAOP=disable
#spi.RabbitmqConvertAOP=disable
#spi.RabbitmqDeliveryAOP=disable
#spi.RabbitmqPublishAOP=disable
#spi.RabbitmqConsumeChannelAOP=disable
#spi.RabbitmqPublishChannelAOP=disable
#spi.DubboServerAOP=disable
#spi.DubboClientAOP=disable
#spi.ConsumeBatchConvert=disable
#spi.ConsumeAOP=disable
#spi.PublishAOP=disable
#spi.ControllerAOP=disable

# 忽略增强的classLoader类名（部分类加载器增强时会导致找不到类而启动不了），多个使用英文逗号分隔
ignore.classLoaderNames=com.vip.saturn.job.executor.JobClassLoader
# 忽略增强的类正则，使用\r\n分隔多个配置
ignore.enhance.classRegular=
# 忽略增强的方法正则，使用\r\n分隔多个配置
ignore.enhance.methodRegular=


############################ 缓存长度配置
# 方法调用事件的缓存队列长度，必须为2的N次方，需考虑占用内存，太小可能导致事件丢弃
bufferSize.metric=65536
# 链路Span缓存队列长度，必须为2的N次方，需考虑占用内存，太小可能导致事件丢弃
bufferSize.trace=65536
# 事件订阅缓存队列长度，必须为2的N次方，需考虑占用内存，太小可能导致事件丢弃
bufferSize.subcribeEvent=8192
# 数据上报缓存队列长度，必须为2的N次方，需考虑占用内存，太小可能导致事件丢弃
bufferSize.report=8192

############################ 监控数据输出间隔配置
# 方法调用事件的缓存队列发布事件统计输出间隔秒数
metricOutput.interval.publish.metric=10
# 链路Span缓存队列发布事件统计输出间隔秒数
metricOutput.interval.publish.trace=10
# 事件订阅缓存队列发布事件统计输出间隔秒数
metricOutput.interval.publish.subcribeEvent=10
# 数据上报缓存队列发布事件统计输出间隔秒数
metricOutput.interval.publish.report=10
# metric事件消费统计数据输出间隔秒数
metricOutput.interval.consume.metric=10
# 链路Span缓存队列消费事件统计输出间隔秒数
metricOutput.interval.consume.trace=10
# 事件订阅缓存队列消费事件统计输出间隔秒数
metricOutput.interval.consume.subcribeEvent=10
# 数据上报缓存队列消费事件统计输出间隔秒数
metricOutput.interval.consume.report=10
# jvm监控数据输出间隔秒数
metricOutput.interval.jvm=10
# 池监控统计数据输出间隔秒数
metricOutput.interval.pool=10
# 运行心跳数据输出间隔秒数
metricOutput.interval.heartbeat=10

# 定时任务调度核心线程数，只要继承ISchedule的类都使用此处的线程调度
schedule.corePoolSize=5


############################ 自定义类方法QPS/RT配置
# 自定义实例方法RT统计配置
#InstanceMethodMatcher.test3=.*cn\\.ecpark\\.tool\\.javaagent\\.TestService\\.add\\(.*
#InstanceMethodMatcher.test=.*java\\.util\\.concurrent\\.ThreadPoolExecutor\\.execute\\(.*
#InstanceMethodMatcher.test2=.*java\\.util\\.concurrent\\.ArrayBlockingQueue\\.add\\(.*
# 自定义静态方法RT统计配置
#StatisticMethodMatcher.test3=.*cn\\.ecpark\\.tool\\.javaagent\\.TestService\\.multiply\\(.*
#StatisticMethodMatcher.test=.*java\\.time\\.Duration\\.ofHours\\(.*


############################ 上报配置
# 全局默认上报统计数据使用的report类型，可配置多个，多个使用英文逗号分隔
report=log
#report配置中包含http才需要配置，目前为全局配置，不能针对不同的类型设置不同的上报地址
#report.http.url=http://localhost:9411/api/v2/spans
report.http.url=http://localhost:9988/server/test
# 一种类型数据上报使用的类型，可配置多个，多个使用英文逗号分隔，如果希望异步带缓冲的方式上报，则在key后增加.async，代码中MultiReportFactory.getReport的参数不用带.async
report.statistic=log
# Span上报方式，直接上报Span到zipkin后台方便测试，地址配置为：report.http.url
#report.spanListener=http
# 启动状态变更异步上传到服务端，目前应用在服务启动、关闭、心跳上
report.runStatus.async=http
# 自定义监控数据上报方式
report.collect=log
# 池监控数据上报方式
report.poolMonitor=log
# JVM监控数据上报方式
report.jvmMetric=log
# 缓冲事件发布数据监控上报方式
report.eventPublish=log
# 缓冲事件监听数据监控上报方式
report.eventListener=log

############################ 消费线程数配置
# metric事件消费线程数，如果数量大于1，按照事件类型hash值分配到不同的消费线程上
consume.threadNum.metric=5
# 链路跟踪Span上报线程个数，如果数量大于1，多线程随机消费
consume.threadNum.trace=5
# 事件订阅通知线程个数，如果数量大于1，多线程按照类名及方法名hash值分配到不同的消费线程上
consume.threadNum.subcribeEvent=2
# 异步上报线程个数，如果数量大于1，多线程按照report类型hash值分配到不同的消费线程上
consume.threadNum.report=3

############################ 链路采样率配置
# 全局采样量配置，如果配置了该值，则类型采样量配置自动失效，全局限制，仅针对sample.strategy为leader或followerAndLeader
#trace.sample.qps.global=100
# 每秒默认采样span个数，仅针对sample.strategy为leader或followerAndleader，如果类型采样量未配置则使用该值
trace.sample.qps.default=100
# 每种类型的Span采样策略
	# key说明：trace.sample.strategy.类型
	# 值说明：none - 不采样；
			# always - 都采样；
			# follower - 跟随，如果上游包含了链路则生成Span，否则忽略，默认为该值；
			# leader - 使用采样量决定要不要生成Span；
			# followerAndLeader - 上游存在链路则生成Span，否则按照采样量生成；
trace.sample.strategy.mq-publish=always
# kafka采样量配置，sample.strategy为leader或followerAndleader配置生效，未配置类型采样量则使用trace.sample.qps.default
#trace.sample.qps.mq-publish=20
trace.sample.strategy.mq-consume=always
#trace.sample.qps.mq-consume=20
# TODO 上线前修改采样率配置
trace.sample.strategy.dubbo-client=always
trace.sample.strategy.dubbo-server=always

# metric事件堆积量超过buffer时是否丢弃新产生的事件，如果配置为false有可能影响服务正常调用速度，默认为true
eventPublish.discard.metric=true
# trace span堆积量超过buffer时是否丢弃新产生的事件，如果配置为false有可能影响服务正常调用速度，默认为true
eventPublish.discard.trace=true
# 订阅事件堆积量超过buffer时是否丢弃新产生的事件，如果配置为false有可能影响服务正常调用速度，默认为true（eventSubscribe.callAsync为true时生效）
eventPublish.discard.subcribeEvent=true


# 订阅事件检测死循环的最小调用栈大小，避免因代码错误导致死循环同时也降低检测性能损耗，如果死循环时的调用栈长度小于该值，则需要人为调小该值，默认为10
eventSubscribe.check.minSize=10
# 事件的订阅是否与事件源处于同一个线程同步调用，默认为true
eventSubscribe.callAsync=true
# 事件订阅配置，格式为：eventSubscribe.xxx=source classMethodRegular > subscribe className.methodRegular
# 	其中xxx为自定义字符串，代表事件分组，如果其中包含.ignoreParams.则事件方法中的参数不会传递到订阅方法的参数中，source cclassMethodRegular为被订阅类方法正则，subscribe className.methodRegular为订阅类全称及方法正则，其中方法正则中必须包含一个参数起始(
#	如果key中不包含.ignoreParams.，则subscribe className.methodRegular的方法参数与source classMethodRegular的方法参数必须对应，subscribe方法参数后面可多出3中类型的参数：source类实例、source className.methodRegular返回值、Throwable，这三个参数的位置不限先后
# 该功能用于简化方法调用通知的实现，通过配置即可订阅方法调用事件（如果使用代理的方式实现，需要研发额外开发代码，而且针对jar包中的很多类无法做到代理拦截）
# 配置支持一个方法被多个注册者监听，一个监听者也可以监听多个方法，多对多的关系
# 注意：在订阅类中不能再调用被订阅类的订阅方法，否则会导致死循环(已做了运行限制)；事件的通知是异步的，如果消费慢于生产可能导致事件丢弃；在一个分组内的事件通知为单线程调用；
eventSubscribe.group.xxx1=.*com\\.yametech\\.yangjian\\.agent\\.core\\.eventsubscribe\\.Service\\.test1\\(.* > com.yametech.yangjian.agent.core.eventsubscribe.Listener.test1\\(.*
eventSubscribe.group.xxx2=.*com\\.yametech\\.yangjian\\.agent\\.core\\.eventsubscribe\\.Service\\.test1\\(.* > com.yametech.yangjian.agent.core.eventsubscribe.Listener.test1_1\\(.*
eventSubscribe.group.xxx3=.*com\\.yametech\\.yangjian\\.agent\\.core\\.eventsubscribe\\.Service\\.test1\\(.* > com.yametech.yangjian.agent.core.eventsubscribe.Listener.test1_2\\(.*
eventSubscribe.group.ignoreParams.xxx4=.*com\\.yametech\\.yangjian\\.agent\\.core\\.eventsubscribe\\.Service\\.test2\\(.* > com.yametech.yangjian.agent.core.eventsubscribe.Listener.test2\\(.*
eventSubscribe.group.ignoreParams.xxx5=.*com\\.mongodb\\.Mongo\\$3\\.execute\\(.*,com\\.mongodb\\.session\\.ClientSession\\).* > cn.ecpark.tool.monitor.EventSubscribeTest.test\\(.*
